# 구글 애즈 조직 단위 토큰 공유 작업 내역 (2026-01-20 ~ 2026-01-21)

## 작업 개요

**목적**: 같은 조직 내에서 기존 Google Ads Refresh Token을 재사용하여 중복 OAuth 인증 방지

**상태**: ✅ **완료** (2026-01-21)

---

## 완료된 작업

### 1. ✅ PostgreSQL RPC 함수 오류 수정 (2026-01-20)

**문제**: `get_organization_google_tokens` RPC 함수 호출 시 오류
```
column reference "organization_id" is ambiguous
```

**원인**: PL/pgSQL 변수명 `v_org_id`와 테이블 컬럼명 `organization_id` 충돌

**해결**:
- **파일**: `supabase/migrations/034_organization_shared_tokens.sql`
- **수정**: 변수명 `v_org_id` → `v_current_org_id` (4곳)
  - 40번째 줄: DECLARE 블록
  - 50번째 줄: SELECT INTO 구문
  - 82번째 줄: NULL 체크
  - 100번째 줄: WHERE 조건
- **결과**: RPC 함수 정상 작동 확인 ✅

---

### 2. ✅ 토큰 선택 시 Refresh Token 자동입력 추가 (2026-01-20)

**문제**: 기존 토큰 선택 시 Refresh Token이 자동으로 필드에 입력되지 않음

**분석**:
- **OAuth 성공 시**: `oauth-callback.html`에서 평문 토큰을 postMessage로 전달 → 자동입력 ✅
- **기존 토큰 선택 시**: `integration_id`만 저장하고 토큰 복호화 없음 ❌

**해결**:
- **파일**: `src/views/superadmin/api-management/components/APITokenTable.js`
- **함수**: `handleSelectToken` (657-714번째 줄)
- **수정 내용**:
  ```javascript
  const handleSelectToken = async (integrationId) => {
    setSelectedIntegrationId(integrationId);

    // Refresh Token 복호화 및 자동입력
    const { data: decryptedToken } = await supabase.rpc('get_decrypted_token', {
      p_api_token_id: integrationId,
      p_token_type: 'refresh_token',
    });

    if (decryptedToken) {
      setFormData(prev => ({
        ...prev,
        refreshToken: decryptedToken,
      }));
    }

    onTokenSelectModalClose();
  };
  ```
- **결과**: 토큰 선택 시 Refresh Token 자동입력 확인 ✅

---

### 3. ✅ Google 브랜드 목록 조회 Edge Function 수정 (2026-01-21)

#### 3-1. 문제 진단

**초기 에러**:
```
Operation is not implemented, or supported, or enabled
(Google Ads API 501 에러)
```

**원인 분석**:
1. **API 버전 불일치**: v18 (deprecated) 사용, v22로 업그레이드 필요
2. **MCC 헤더 누락**: Manager 계정 조회를 위한 `login-customer-id` 헤더 필요
3. **API 메소드 변경**: `googleAds:search` → `googleAds:searchStream` 변경 필요
4. **응답 파싱**: newline-delimited JSON 파싱 필요

#### 3-2. Edge Function 수정

**파일**: `supabase/functions/list-google-customers/index.ts`

**변경 1: Integration 쿼리에 MCC ID 추가** (Line 51)
```typescript
// 변경 전
.select('id, platform, advertiser_id, advertisers(organization_id)')

// 변경 후
.select('id, platform, advertiser_id, legacy_manager_account_id, advertisers(organization_id)')
```

**변경 2: API v18 → v22 + MCC 헤더 추가** (Line 155-173)
```typescript
// MCC ID 추출
const managerAccountId = integration.legacy_manager_account_id;

// 헤더 구성
const listHeaders: any = {
  'Authorization': `Bearer ${access_token}`,
  'developer-token': developerToken,
};

if (managerAccountId) {
  listHeaders['login-customer-id'] = managerAccountId;
}

// API 호출 (v18 → v22)
const listResponse = await fetch(
  'https://googleads.googleapis.com/v22/customers:listAccessibleCustomers',
  { headers: listHeaders }
);
```

**변경 3: searchStream 적용** (Line 198-234)
```typescript
const detailHeaders: any = {
  'Authorization': `Bearer ${access_token}`,
  'developer-token': developerToken,
  'Content-Type': 'application/json',
};

if (managerAccountId) {
  detailHeaders['login-customer-id'] = managerAccountId;
}

const detailResponse = await fetch(
  `https://googleads.googleapis.com/v22/customers/${customerId}/googleAds:searchStream`,
  {
    method: 'POST',
    headers: detailHeaders,
    body: JSON.stringify({ query }),
  }
);

// newline-delimited JSON 파싱
const responseText = await detailResponse.text();
const allResults = parseGoogleAdsResponse(responseText);
const result = allResults[0]?.customer;
```

**변경 4: 응답 파서 함수 추가** (Line 245-284)
```typescript
function parseGoogleAdsResponse(responseText: string): any[] {
  let allResults: any[] = [];

  try {
    // 완전한 JSON 배열로 파싱 시도
    const jsonArray = JSON.parse(responseText);
    if (Array.isArray(jsonArray)) {
      for (const item of jsonArray) {
        if (item.results && Array.isArray(item.results)) {
          allResults = allResults.concat(item.results);
        }
      }
    } else if (jsonArray.results && Array.isArray(jsonArray.results)) {
      allResults = jsonArray.results;
    }
  } catch {
    // Fallback: newline-delimited JSON 파싱
    const lines = responseText.trim().split('\n').filter(line => line.trim());
    for (const line of lines) {
      try {
        const json = JSON.parse(line);
        if (json.results && Array.isArray(json.results)) {
          allResults = allResults.concat(json.results);
        }
      } catch {
        // 개별 라인 파싱 실패 무시
      }
    }
  }

  return allResults;
}
```

---

### 4. ✅ 프론트엔드 API 호출 수정 (2026-01-21)

**문제**: 401 Unauthorized 에러 발생

**원인**: Edge Function 호출 시 `apikey` 헤더 누락

**해결**:
- **파일**: `src/views/superadmin/api-management/components/APITokenTable.js`
- **위치**: Line 735-744 (`handleFetchGoogleCustomers` 함수)
- **수정**:
  ```javascript
  const response = await fetch(`${process.env.REACT_APP_SUPABASE_URL}/functions/v1/list-google-customers`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${accessToken}`,
      'apikey': process.env.REACT_APP_SUPABASE_ANON_KEY,  // ✅ 추가
    },
    body: JSON.stringify({
      integration_id: selectedIntegrationId,
    }),
  });
  ```
- **결과**: 인증 문제 해결 ✅

---

## 최종 결과

### ✅ 성공 시나리오

1. `/superadmin/api-management` 접속
2. 브랜드 선택
3. "Google 계정 연결" 클릭
4. **조직의 기존 토큰 목록 표시** ✅
5. **토큰 선택 → Refresh Token 자동입력** ✅
6. **"Google 브랜드 목록 조회" 클릭** ✅
7. **Customer 목록 드롭다운 표시** ✅
8. Customer 선택 → Customer ID 자동입력
9. 저장 완료

### 주요 개선사항

1. **API 표준화**: Google Ads API v22 사용 (데이터 수집기와 동일)
2. **MCC 지원**: Manager 계정의 하위 계정 조회 가능
3. **안정성 향상**: 표준 API 메소드 사용으로 호환성 보장
4. **토큰 재사용**: 조직 내 기존 토큰 선택으로 중복 OAuth 방지

---

## 수정된 파일 목록

### Edge Function
- `supabase/functions/list-google-customers/index.ts`
  - Line 51: Integration 쿼리 수정 (MCC ID 추가)
  - Line 155-173: API v22 + MCC 헤더
  - Line 198-234: searchStream 적용
  - Line 245-284: 응답 파서 함수 추가

### 프론트엔드
- `src/views/superadmin/api-management/components/APITokenTable.js`
  - Line 657-714: `handleSelectToken` - Refresh Token 자동입력
  - Line 735-744: `handleFetchGoogleCustomers` - apikey 헤더 추가

### SQL 마이그레이션
- `supabase/migrations/034_organization_shared_tokens.sql`
  - Line 40, 50, 82, 100: 변수명 충돌 해결

---

## 기술 상세

### API 변경 사항

| 항목 | 변경 전 (v18) | 변경 후 (v22) |
|------|--------------|--------------|
| API 버전 | v18 | v22 |
| listAccessibleCustomers | v18/customers:listAccessibleCustomers | v22/customers:listAccessibleCustomers |
| 상세 조회 메소드 | googleAds:search | googleAds:searchStream |
| 응답 형식 | JSON 객체 | Newline-delimited JSON |
| MCC 헤더 | 없음 | login-customer-id (조건부) |

### 응답 파싱 방식

**v18 (구)**:
```javascript
const detailData = await detailResponse.json();
const result = detailData.results?.[0]?.customer;
```

**v22 (신)**:
```javascript
const responseText = await detailResponse.text();
const allResults = parseGoogleAdsResponse(responseText);
const result = allResults[0]?.customer;
```

---

## 배포 명령어

### Edge Function 배포
```bash
cd "c:\Users\REON\Desktop\새 폴더\growth-dashboard"
export SUPABASE_ACCESS_TOKEN="sbp_..."
npx supabase functions deploy list-google-customers --no-verify-jwt
```

### 테스트
1. 브라우저 하드 리프레시 (Ctrl+Shift+R)
2. `/superadmin/api-management` 페이지 접속
3. Google 브랜드 목록 조회 테스트

---

## 참고 링크

- **Supabase Project**: https://supabase.com/dashboard/project/qdzdyoqtzkfpcogecyar
- **Edge Functions Dashboard**: https://supabase.com/dashboard/project/qdzdyoqtzkfpcogecyar/functions
- **Google Ads API v22 Docs**: https://developers.google.com/google-ads/api/docs/start

---

## 작업 시간

- **시작**: 2026-01-20
- **완료**: 2026-01-21
- **소요 시간**: 약 4시간

---

## 변경하지 않은 파일 (기존 작동 기능 유지)

✅ 다음 파일들은 수정하지 않았으며 정상 작동 확인:
- `supabase/functions/oauth-callback/index.ts` (OAuth 토큰 저장)
- `supabase/functions/oauth-initiate/index.ts` (OAuth 인증 시작)
- `supabase/functions/collect-ad-data/index.ts` (데이터 수집)
- `supabase/functions/resolve-access-token/index.ts` (Meta 토큰 조회)
- `public/oauth-callback.html` (postMessage 처리)
- Meta Ads 관련 모든 로직

**영향 범위**: Google 브랜드 목록 조회 기능만 수정, 기존 데이터 수집 및 OAuth 로직 영향 없음 ✅
