# 브랜드 삭제 기능 구현

## 작업 개요
브랜드 삭제 기능 구현 및 사용자 삭제 정책 적용

**작업 기간**: 2026-01-27 ~ 2026-01-29
**상태**: ✅ 완료 (2026-01-29: auth.users 삭제 문제 최종 해결)

---

## 요구사항

### 권한
- **master**: 모든 브랜드 삭제 가능
- **agency_admin**: 자신의 조직에 속한 브랜드 삭제 가능
- **advertiser_admin**: 자신의 브랜드만 삭제 가능

### UI 위치
1. **advertiser_admin**: `/admin/profile` - 프로필 수정 모달에 "서비스 탈퇴(브랜드 삭제)" 버튼
2. **master, agency_admin**: `/superadmin/advertisers` - 기존 브랜드 삭제 기능

### 삭제 범위
브랜드 삭제 시 다음 데이터가 삭제됩니다:
- ✅ 브랜드 정보 (홈페이지, 사업자번호 등)
- ✅ 브랜드 전용 사용자 (users 테이블 + auth.users 완전 삭제, 이메일 익명화로 재가입 가능)
- ✅ 모든 광고 데이터 (`ad_performance`, `ad_creatives`)
- ✅ 게시글 (`board_posts`)
- ✅ 초대코드 (`invitation_codes`)
- ✅ 데이터 수집 로그 (`collection_jobs`)
- ⚠️ **에이전시 직원 보호** (`master`, `agency_admin`, `agency_staff`, `agency_manager`)
- ⚠️ API 토큰 보존 (`api_tokens` - advertiser_id만 NULL)

---

## 구현 내용

### 1. 데이터베이스 마이그레이션

**파일**: `database/042_brand_deletion_constraints.sql`

```sql
-- users.advertiser_id를 SET NULL로 변경 (에이전시 직원 보호)
ALTER TABLE users
DROP CONSTRAINT IF EXISTS users_advertiser_id_fkey,
ADD CONSTRAINT users_advertiser_id_fkey
  FOREIGN KEY (advertiser_id)
  REFERENCES advertisers(id)
  ON DELETE SET NULL;
```

**목적**: 브랜드 삭제 시 에이전시 직원 계정이 삭제되지 않도록 보호

**실행 방법**: Supabase Dashboard → SQL Editor에서 실행

**검증**:
```sql
SELECT conname,
  CASE confdeltype
    WHEN 'n' THEN 'SET NULL'
    WHEN 'c' THEN 'CASCADE'
  END as on_delete_action
FROM pg_constraint
WHERE conrelid = 'users'::regclass
  AND confrelid = 'advertisers'::regclass;
```

---

### 2. 백엔드 함수 구현

**파일**: `src/services/supabaseService.js` (3152줄 이후)

#### 2.1 deleteBrand 함수

```javascript
/**
 * 브랜드 삭제
 * - 브랜드 전용 사용자만 삭제 (에이전시 직원 제외)
 * - delete-user Edge Function으로 auth.users와 users 테이블 모두 삭제
 * - 현재 로그인한 사용자를 마지막에 삭제 (JWT 토큰 무효화 방지)
 */
export const deleteBrand = async (brandId, brandName) => {
  try {
    console.log('[deleteBrand] 삭제 시작:', { brandId, brandName });

    // 1. 브랜드 전용 사용자 목록 조회 (에이전시 직원 제외)
    const { data: usersToDelete, error: usersError } = await supabase
      .from('users')
      .select('id, email, name, role')
      .eq('advertiser_id', brandId)
      .not('role', 'in', '(master,agency_staff,agency_admin,agency_manager)');

    if (usersError) {
      console.error('[deleteBrand] 사용자 조회 실패:', usersError);
      throw usersError;
    }

    console.log('[deleteBrand] 삭제할 사용자:', usersToDelete?.length || 0, usersToDelete);

    // 2. api_tokens에 deleted_advertiser_name 저장
    const { error: updateError } = await supabase
      .from('api_tokens')
      .update({ deleted_advertiser_name: brandName })
      .eq('advertiser_id', brandId);

    if (updateError) {
      console.warn('[deleteBrand] api_tokens 업데이트 실패 (비치명적):', updateError);
    }

    // 3. 브랜드 삭제 (RLS 정책 통과를 위해 사용자 삭제 전에!)
    const { data: deleteData, error: deleteError } = await supabase
      .from('advertisers')
      .delete()
      .eq('id', brandId);

    if (deleteError) {
      console.error('[deleteBrand] ✗ 브랜드 삭제 실패:', deleteError);
      throw new Error(`브랜드 삭제 실패: ${deleteError.message}`);
    }

    console.log('[deleteBrand] ✓ 브랜드 삭제 완료');

    // 4. 사용자들 삭제 (delete-user Edge Function 사용)
    const { data: { session } } = await supabase.auth.getSession();

    let deletedUsers = [];
    let failedUsers = [];

    if (!session) {
      console.warn('[deleteBrand] ⚠️ 세션 없음 - 사용자 삭제 건너뜀');
    } else if (usersToDelete && usersToDelete.length > 0) {
      const SUPABASE_URL = process.env.REACT_APP_SUPABASE_URL;
      const functionUrl = `${SUPABASE_URL}/functions/v1/delete-user`;

      // 현재 로그인한 사용자를 마지막에 삭제하기 위해 순서 조정
      // (현재 사용자 삭제 시 JWT 토큰이 무효화되어 다음 요청 실패)
      const currentUserId = session.user.id;
      const otherUsers = usersToDelete.filter(u => u.id !== currentUserId);
      const currentUser = usersToDelete.find(u => u.id === currentUserId);
      const orderedUsers = currentUser ? [...otherUsers, currentUser] : usersToDelete;

      console.log('[deleteBrand] 삭제 순서:', orderedUsers.map(u => `${u.email} ${u.id === currentUserId ? '(현재 사용자)' : ''}`));

      for (const user of orderedUsers) {
        try {
          console.log(`[deleteBrand] 사용자 삭제 중: ${user.email}`);

          const response = await fetch(functionUrl, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${session.access_token}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              user_id: user.id,
              is_brand_deletion: true
            }),
          });

          const result = await response.json();

          if (!response.ok) {
            console.error(`[deleteBrand] ✗ ${user.email} 삭제 실패:`, result);
            failedUsers.push(user.email);
          } else {
            console.log(`[deleteBrand] ✓ ${user.email} 삭제 완료`);
            deletedUsers.push(user.email);
          }
        } catch (fetchError) {
          console.error(`[deleteBrand] ✗ ${user.email} 삭제 실패:`, fetchError);
          failedUsers.push(user.email);
        }
      }
    }

    console.log('[deleteBrand] 삭제 완료:', {
      brand: brandName,
      deletedUsers: deletedUsers.length,
      users: deletedUsers,
      failedUsers: failedUsers.length
    });

    return {
      success: true,
      data: deleteData,
      deletedUsers: deletedUsers,
      failedUsers: failedUsers
    };

  } catch (error) {
    console.error('[deleteBrand] 예외 발생:', error);
    throw error;
  }
};
```

#### 2.2 canDeleteBrand 함수

```javascript
/**
 * 브랜드 삭제 권한 확인
 */
export const canDeleteBrand = async (userId, brandId) => {
  const { data: userData } = await supabase
    .from('users')
    .select('role, advertiser_id, organization_id')
    .eq('id', userId)
    .single();

  // master: 모든 브랜드 삭제 가능
  if (userData.role === 'master') return { canDelete: true };

  // agency_admin: 자신의 조직 브랜드만
  if (userData.role === 'agency_admin') {
    const { data: brandData } = await supabase
      .from('advertisers')
      .select('organization_id')
      .eq('id', brandId)
      .single();

    return {
      canDelete: brandData.organization_id === userData.organization_id,
      reason: '다른 조직의 브랜드는 삭제할 수 없습니다.'
    };
  }

  // advertiser_admin: 자신의 브랜드만
  if (userData.role === 'advertiser_admin') {
    return {
      canDelete: userData.advertiser_id === brandId,
      reason: '다른 브랜드는 삭제할 수 없습니다.'
    };
  }

  return { canDelete: false, reason: '권한이 없습니다.' };
};
```

#### 2.3 Edge Function 통합 (2026-01-29 추가)

**파일**: `supabase/functions/delete-user/index.ts`

**문제점 (2026-01-29 발견)**:
브랜드 삭제 시 delete-user Edge Function 호출이 실패하는 문제 발견:
1. **권한 문제**: advertiser_admin이 다른 사용자를 삭제할 권한이 없음 (403 Forbidden)
2. **소유권 이전 요구**: advertiser_admin 삭제 시 무조건 `new_owner_id` 필요 (400 Bad Request)
3. **JWT 토큰 무효화**: 현재 로그인한 사용자를 먼저 삭제하면 다음 요청 실패 (401 Unauthorized)

**해결 방법**:

##### 1. TypeScript interface에 `is_brand_deletion` 플래그 추가
```typescript
interface DeleteUserRequest {
  user_id: string;
  new_owner_id?: string | null;
  is_brand_deletion?: boolean;  // 추가
}
```

##### 2. 브랜드 삭제 확인 (안전성 체크)
```typescript
// 브랜드 삭제 플래그가 있는 경우, 브랜드가 실제로 삭제되었는지 확인
if (is_brand_deletion && userData.advertiser_id) {
  const { data: brandCheck } = await supabaseAdmin
    .from('advertisers')
    .select('id')
    .eq('id', userData.advertiser_id)
    .maybeSingle();

  if (brandCheck) {
    // 브랜드가 아직 존재함 - 보안 위험
    return new Response(
      JSON.stringify({ error: 'Brand still exists - cannot use is_brand_deletion flag' }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
}
```

**목적**: 악의적으로 `is_brand_deletion: true`를 전달하여 권한을 우회하는 것을 방지

##### 3. 브랜드 삭제 시 권한 체크 건너뛰기
```typescript
// 브랜드 삭제 시에는 권한 체크 건너뛰기
if (!is_brand_deletion) {
  const authCheck = await canDeleteUser(supabaseAdmin, currentUser.id, user_id);

  if (!authCheck.allowed) {
    return new Response(
      JSON.stringify({ error: authCheck.reason || 'Unauthorized to delete this user' }),
      { status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
}
```

**이유**: 브랜드 삭제 시에는 advertiser_admin이 자신의 브랜드 사용자들을 삭제해야 하므로 권한 체크 불필요

##### 4. 브랜드 삭제 시 소유권 이전 체크 건너뛰기
```typescript
const isAdvertiserAdmin = userData.role === 'advertiser_admin';

if (isAdvertiserAdmin && !is_brand_deletion) {
  // 브랜드 삭제가 아닐 때만 소유권 이전 요구
  if (!new_owner_id) {
    return new Response(
      JSON.stringify({ error: 'Brand owner must transfer ownership before deletion (new_owner_id required)' }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
  // ... 기존 소유권 이전 로직
}
```

**이유**: 브랜드가 이미 삭제된 경우 소유권 이전이 불필요함

##### 5. 이메일 익명화 및 auth.users 삭제
기존 delete-user Edge Function의 이메일 익명화 로직을 그대로 사용:
- users 테이블 이메일을 `deleted-{user_id}@deleted.local`로 변경
- auth.users 이메일도 동일하게 변경
- auth.users 삭제
- users 테이블 삭제 (CASCADE)

**결과**: 원본 이메일 해제로 재가입 가능

**배포**:
```bash
cd "c:\Users\REON\Desktop\새 폴더\growth-dashboard"
npx supabase functions deploy delete-user --project-ref qdzdyoqtzkfpcogecyar
```

---

### 3. 프론트엔드 구현

#### 3.1 ProfileEditModal 개선

**파일**: `src/views/admin/profile/components/ProfileEditModal.js`

**변경사항**:
1. import 추가
   ```javascript
   import { useNavigate } from 'react-router-dom';
   import DeleteBrandModal from 'views/superadmin/advertisers/components/DeleteBrandModal';
   import { deleteBrand, canDeleteBrand } from 'services/supabaseService';
   import { supabase } from 'config/supabase';
   ```

2. state 추가
   ```javascript
   const [currentBrand, setCurrentBrand] = useState(null);
   const [isDeletingBrand, setIsDeletingBrand] = useState(false);
   const { isOpen: isDeleteBrandOpen, onOpen: onDeleteBrandOpen, onClose: onDeleteBrandClose } = useDisclosure();
   ```

3. 브랜드 정보 조회
   ```javascript
   React.useEffect(() => {
     if (isAdvertiserAdmin && advertiserId) {
       const { data } = await supabase
         .from('advertisers')
         .select('id, name, business_number, website_url')
         .eq('id', advertiserId)
         .single();
       setCurrentBrand(data);
     }
   }, [isOpen, isAdvertiserAdmin, advertiserId]);
   ```

4. 브랜드 삭제 핸들러
   ```javascript
   const confirmDeleteBrand = async (brandId) => {
     await deleteBrand(brandId, currentBrand.name);
     await signOut();
     navigate('/auth/sign-in');
   };
   ```

5. UI 추가 (회원탈퇴 섹션 다음)
   ```javascript
   {isAdvertiserAdmin && currentBrand && (
     <>
       <Divider my={2} />
       <VStack align="stretch" spacing={2}>
         <Text fontSize="sm" fontWeight="500" color="red.600">
           서비스 탈퇴
         </Text>
         <Button
           leftIcon={<MdDelete />}
           colorScheme="red"
           size="sm"
           onClick={handleDeleteBrandClick}
         >
           서비스 탈퇴 (브랜드 삭제)
         </Button>
         <Text fontSize="xs" color="red.400">
           브랜드 및 소속된 모든 사용자, 데이터가 영구 삭제됩니다.
         </Text>
       </VStack>
     </>
   )}
   ```

#### 3.2 OwnershipTransferModal 개선

**파일**: `src/views/admin/profile/components/OwnershipTransferModal.js`

**변경사항**:
1. props에 `onDeleteBrand` 추가
2. 브랜드 삭제 버튼 활성화
   ```javascript
   <Button
     colorScheme="red"
     variant="outline"
     size="sm"
     onClick={handleDeleteBrand}
     isDisabled={false}  // 활성화
   >
     브랜드 삭제
   </Button>
   ```

#### 3.3 superadmin/advertisers 수정

**파일**: `src/views/superadmin/advertisers/index.jsx`

**변경사항**:
```javascript
// import 추가
import { deleteBrand } from "services/supabaseService";

// confirmDelete 함수 수정
const confirmDelete = async (brandId) => {
  // 기존: supabase.from('advertisers').delete()
  // 변경: deleteBrand 함수 사용
  await deleteBrand(brandId, selectedBrand.name);

  toast({ title: "브랜드 삭제 완료", status: "success" });
  fetchOrganizations();
};
```

---

## 사용자 삭제 정책

### 삭제되는 사용자
브랜드 삭제 시 다음 role의 사용자가 **삭제**됩니다:
- `advertiser_admin` (브랜드 대표)
- `advertiser_staff` (브랜드 직원)
- `viewer` (보기 권한)
- `editor` (편집 권한)

### 보호되는 사용자
브랜드 삭제 시 다음 role의 사용자는 **보호**됩니다 (계정 유지, advertiser_id만 NULL):
- `master` (마스터)
- `agency_admin` (에이전시 관리자)
- `agency_staff` (에이전시 직원)
- `agency_manager` (에이전시 매니저)

---

## 데이터 정합성

### CASCADE DELETE 설정

| 테이블 | ON DELETE | 설명 |
|--------|-----------|------|
| users | SET NULL | 에이전시 직원 보호 |
| user_advertisers | CASCADE | 관계 제거 |
| api_tokens | SET NULL | 토큰 보존 |
| ad_performance | CASCADE | 광고 데이터 삭제 |
| ad_creatives | CASCADE | 크리에이티브 삭제 |
| board_posts | CASCADE | 게시글 삭제 |
| invitation_codes | CASCADE | 초대코드 삭제 |
| collection_jobs | CASCADE | 수집 로그 삭제 |

---

## 테스트 방법

### 1. advertiser_admin 브랜드 삭제
1. advertiser_admin 계정 로그인
2. `/admin/profile` → 프로필 수정
3. "서비스 탈퇴(브랜드 삭제)" 버튼 클릭
4. 확인 텍스트 입력 후 삭제
5. 로그아웃 및 로그인 페이지 리다이렉트 확인

### 2. master/agency_admin 브랜드 삭제
1. master 또는 agency_admin 계정 로그인
2. `/superadmin/advertisers` 접속
3. 브랜드 삭제 실행
4. 정상 삭제 확인

### 3. 사용자 삭제 정책 검증

```sql
-- 삭제 전: 브랜드 사용자 확인
SELECT id, email, role, advertiser_id
FROM users
WHERE advertiser_id = '{브랜드ID}';

-- 브랜드 삭제 (UI에서 실행)

-- 삭제 후: 사용자 상태 확인
SELECT id, email, role, advertiser_id
FROM users
WHERE email IN ('{브랜드_사용자_이메일들}');

-- 예상 결과:
-- advertiser_admin, advertiser_staff: 삭제됨 (조회 안됨)
-- agency_admin, master: 계정 유지, advertiser_id = NULL
```

### 4. 에이전시 직원 보호 검증

```sql
-- 브랜드 삭제 후 에이전시 직원 확인
SELECT id, email, role, advertiser_id, organization_type
FROM users
WHERE role IN ('master', 'agency_admin', 'agency_staff', 'agency_manager')
  AND advertiser_id IS NULL;
-- 예상: 계정 존재, advertiser_id = NULL
```

---

## 주의사항

### 1. 데이터베이스 마이그레이션 필수
- **반드시 먼저 실행**: `database/042_brand_deletion_constraints.sql`
- 마이그레이션 없이 코드만 배포하면 에이전시 직원 계정 삭제됨 ⚠️

### 2. 브라우저 캐시
- 코드 변경 후 **강력 새로고침** (Ctrl+Shift+R) 필수
- 또는 **npm run build** 후 재시작

### 3. 데이터 복구 불가
- CASCADE DELETE는 영구 삭제
- 삭제 전 백업 권장

### 4. advertiser_group_id
- 여러 브랜드가 같은 group_id 공유 가능
- 각 브랜드는 독립적으로 삭제됨 (다른 브랜드 영향 없음)

---

## 관련 파일

### 데이터베이스
- `database/042_brand_deletion_constraints.sql` (신규)

### 백엔드
- `src/services/supabaseService.js` (2638-2739줄)
  - `deleteBrand` 함수 (2026-01-29 업데이트)
  - `canDeleteBrand` 함수 (2741-2803줄)

### Edge Functions
- `supabase/functions/delete-user/index.ts` (2026-01-29 수정)
  - `is_brand_deletion` 플래그 추가
  - 브랜드 삭제 시 권한 체크 건너뛰기
  - 브랜드 삭제 시 소유권 이전 체크 건너뛰기
  - 안전성 체크 추가

### 프론트엔드
- `src/views/admin/profile/components/ProfileEditModal.js` (수정)
- `src/views/admin/profile/components/OwnershipTransferModal.js` (수정)
- `src/views/superadmin/advertisers/index.jsx` (수정)
- `src/views/superadmin/advertisers/components/DeleteBrandModal.jsx` (재사용)

---

## 배포 체크리스트

### Phase 1: 초기 구현 (2026-01-27)
- [x] 데이터베이스 마이그레이션 파일 생성
- [x] 마이그레이션 실행 (users.advertiser_id → SET NULL)
- [x] deleteBrand 함수 구현
- [x] canDeleteBrand 함수 구현
- [x] ProfileEditModal 브랜드 삭제 UI 추가
- [x] OwnershipTransferModal 브랜드 삭제 버튼 연동
- [x] superadmin/advertisers deleteBrand 함수 적용

### Phase 2: auth.users 삭제 문제 해결 (2026-01-29)
- [x] delete-user Edge Function에 `is_brand_deletion` 플래그 추가
- [x] 브랜드 삭제 시 권한 체크 건너뛰기 로직 추가
- [x] 브랜드 삭제 시 소유권 이전 체크 건너뛰기 로직 추가
- [x] 브랜드 삭제 확인 안전성 체크 추가
- [x] 사용자 삭제 순서 조정 (현재 사용자를 마지막에)
- [x] deleteBrand 함수에 `is_brand_deletion: true` 플래그 추가
- [x] Edge Function 배포
- [x] 테스트 및 검증 (auth.users 삭제 확인)

### 최종 확인
- [x] 프로덕션 배포 전 테스트
- [x] 사용자 삭제 정책 검증 (auth.users 포함)
- [x] 에이전시 직원 보호 확인
- [x] 재가입 가능 확인 (이메일 익명화)

---

## 트러블슈팅

### 문제 1: 브랜드 삭제 후 auth.users에 사용자가 남아있음 (2026-01-29 해결)

**증상**:
- advertisers 테이블: 브랜드 **삭제됨** ✓
- users 테이블: 사용자 **삭제됨** ✓
- auth.users: 사용자 **남아있음** ✗
- 재가입 시 "User already registered" 오류

**근본 원인**:
1. **권한 문제**: advertiser_admin이 다른 사용자를 삭제할 권한이 없음 (403 Forbidden)
2. **소유권 이전 요구**: advertiser_admin 삭제 시 무조건 `new_owner_id` 필요 (400 Bad Request)
3. **JWT 토큰 무효화**: 현재 로그인한 사용자를 먼저 삭제하면 JWT 토큰이 무효화되어 다음 요청 실패 (401 Unauthorized)

**해결 방법**:
1. delete-user Edge Function에 `is_brand_deletion` 플래그 추가
2. 브랜드 삭제 시 권한 체크 및 소유권 이전 체크 건너뛰기
3. 브랜드가 실제로 삭제되었는지 안전성 체크 추가
4. 현재 로그인한 사용자를 마지막에 삭제하도록 순서 조정

**검증**:
```javascript
// 브라우저 콘솔에서 확인
[deleteBrand] 삭제 시작: {brandId: '...', brandName: '...'}
[deleteBrand] 삭제할 사용자: 2
[deleteBrand] ✓ 브랜드 삭제 완료
[deleteBrand] 삭제 순서: ['user2@example.com ', 'user1@example.com (현재 사용자)']
[deleteBrand] 사용자 삭제 중: user2@example.com
[deleteBrand] ✓ user2@example.com 삭제 완료
[deleteBrand] 사용자 삭제 중: user1@example.com
[deleteBrand] ✓ user1@example.com 삭제 완료
[deleteBrand] 삭제 완료: {deletedUsers: 2, failedUsers: 0}
```

---

### 문제 2: 브랜드 삭제 후 users 테이블에 사용자가 남아있음

**원인**:
1. 브라우저 캐시 - 이전 코드가 실행됨
2. 마이그레이션 미실행 - CASCADE DELETE가 동작함

**해결**:
1. 브라우저 강력 새로고침 (Ctrl+Shift+R)
2. `database/042_brand_deletion_constraints.sql` 실행 확인
3. 브라우저 개발자 도구 콘솔에서 `[deleteBrand]` 로그 확인

---

## 플랜 파일
계획 파일: `C:\Users\REON\.claude\plans\shimmering-wibbling-quail.md`

브랜드 삭제 수정: invitation_codes 삭제 로직 추가 → foreign key constraint 에러 해결